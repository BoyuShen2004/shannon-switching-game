<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Shannon Switching Game</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{
            font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
            min-height:100vh;display:flex;justify-content:center;align-items:center;padding:20px}
        .game-container{
            background:rgba(255,255,255,.95);backdrop-filter:blur(10px);
            border-radius:20px;padding:30px;box-shadow:0 20px 40px rgba(0,0,0,.1);
            max-width:900px;width:100%}
        h1{text-align:center;color:#333;margin-bottom:10px;font-size:2.5rem;
            background:linear-gradient(45deg,#667eea,#764ba2);-webkit-background-clip:text;
            -webkit-text-fill-color:transparent;background-clip:text}
        .subtitle{text-align:center;color:#666;margin-bottom:20px;font-size:1.1rem}
        .game-info{
            display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;
            padding:15px;background:linear-gradient(45deg,#f093fb 0%,#f5576c 100%);
            border-radius:15px;color:white}
        .current-player{font-size:1.2rem;font-weight:700}
        .game-status{font-size:1.1rem}
        .controls{display:flex;flex-wrap:wrap;gap:12px;justify-content:center;margin-bottom:14px}
        button{
            padding:12px 18px;border:none;border-radius:25px;cursor:pointer;font-size:1rem;font-weight:600;
            transition:all .3s ease;box-shadow:0 4px 15px rgba(0,0,0,.1)}
        .reset-btn{background:linear-gradient(45deg,#4facfe 0%,#00f2fe 100%);color:#fff}
        .reset-btn:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(0,0,0,.15)}
        .rules-btn{background:linear-gradient(45deg,#a8edea 0%,#fed6e3 100%);color:#333}
        .rules-btn:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(0,0,0,.15)}
        .toolbar{
            display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin:10px 0 6px}
        .select, .toggle{
            background:#fff;border:2px solid #eee;border-radius:12px;padding:8px 12px;font-weight:600}
        .hint{font-size:.9rem;color:#555;text-align:center;margin-top:4px}
        .badge{display:inline-block;background:#eee;border-radius:10px;padding:4px 10px;margin-left:6px;font-size:.85rem}
        .game-board{display:flex;justify-content:center;margin:14px 0}
        svg{border:3px solid #ddd;border-radius:15px;background:#fff;box-shadow:0 10px 30px rgba(0,0,0,.1)}
        .node{cursor:pointer;transition:all .2s ease}
        .node:hover{
            transform: none;
            filter: drop-shadow(0 0 6px rgba(0,0,0,0.3));
        }
        .terminal{fill:#ff6b6b;stroke:#ff5252;stroke-width:3}
        .regular-node{fill:#4ecdc4;stroke:#26a69a;stroke-width:2}
        .ghost-node{fill:#9ad8d4;stroke:#26a69a;stroke-dasharray:3 3}
        .edge{stroke:#666;stroke-width:3;cursor:pointer;transition:all .2s ease}
        .edge:hover{stroke-width:5;stroke:#333}
        .edge.cut{stroke:#ff4757;stroke-width:4;stroke-dasharray:5,5}
        .edge.connected{stroke:#2ed573;stroke-width:5;animation:pulse 1s infinite}
        .edge.editing{stroke:#222;stroke-dasharray:3 6}
        @keyframes pulse{0%{opacity:.7}50%{opacity:1}100%{opacity:.7}}
        .rules{
            background:linear-gradient(45deg,#ffecd2 0%,#fcb69f 100%);padding:20px;border-radius:15px;margin-top:20px;display:none}
        .rules.show{display:block;animation:slideIn .3s ease}
        @keyframes slideIn{from{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}
        .rules h3{color:#333;margin-bottom:10px}
        .rules ul{color:#555;margin-left:20px}
        .rules li{margin:8px 0}
        .winner{text-align:center;padding:20px;background:linear-gradient(45deg,#ff9a9e 0%,#fecfef 100%);
            border-radius:15px;margin-top:20px;font-size:1.3rem;font-weight:700;color:#333;animation:celebrateWin .5s ease}
        @keyframes celebrateWin{0%{transform:scale(.9);opacity:0}100%{transform:scale(1);opacity:1}}
        .divider{height:1px;background:#eee;margin:10px 0}
    </style>
</head>
<body>
<div class="game-container">
    <h1>Shannon Switching Game</h1>
    <p class="subtitle">Connect the red terminals or block the connection!</p>

    <div class="game-info">
        <div class="current-player" id="currentPlayer">Current Player: Short (Connector)</div>
        <div class="game-status" id="gameStatus">Game in progress</div>
    </div>

    <div class="controls">
        <button class="reset-btn" onclick="resetGame()">New Default Graph</button>
        <button class="rules-btn" onclick="toggleRules()">Rules</button>
        <button class="rules-btn" onclick="saveGraph()">Save Graph</button>
        <button class="rules-btn" onclick="loadGraph()">Load Graph</button>
        <button class="rules-btn" onclick="clearGraph()">Clear Graph</button>
    </div>

    <!-- EDIT / PLAY TOOLBAR -->
    <div class="toolbar">
        <label class="select">
            Mode:
            <select id="modeSelect" onchange="setMode(this.value)">
                <option value="play">Play</option>
                <option value="addNode">Add Node</option>
                <option value="addEdge">Add Edge</option>
                <option value="toggleTerminal">Toggle Terminal</option>
                <option value="delete">Delete</option>
                <option value="move">Move Node</option>
            </select>
        </label>
        <span class="badge" id="editHint">Tip: In Add Edge mode, click two nodes to connect them.</span>
    </div>

    <div class="game-board">
        <svg width="700" height="440" id="gameBoard"></svg>
    </div>
    <p class="hint" id="builderStatus"></p>
    <div class="divider"></div>

    <div class="rules" id="rules">
        <h3>How to Play:</h3>
        <ul>
            <li><strong>Short (Connector):</strong> click edges to connect them (green). Create a path between the two red terminals.</li>
            <li><strong>Cut (Blocker):</strong> click edges to cut them (red). Make connection impossible.</li>
            <li>Players alternate turns. Short goes first. Once an edge is chosen, it cannot be changed in Play mode.</li>
            <li><strong>Custom Graphs:</strong> switch Mode to edit the graph (add nodes/edges, choose exactly two terminals, move or delete). Switch back to Play when ready.</li>
        </ul>
    </div>

    <div class="winner" id="winner" style="display:none;"></div>
</div>

<script>
class ShannonSwitchingGame {
    constructor() {
        this.currentPlayer = 'short'; // 'short' or 'cut'
        this.gameOver = false;
        this.edges = [];
        this.nodes = [];
        this.mode = 'play'; // 'play', 'addNode', 'addEdge', 'toggleTerminal', 'delete', 'move'
        this.pendingEdgeFrom = null; // for addEdge
        this.draggingNode = null; // for move
        this.winner = null;

        // default terminals were [0,5]; we now derive them from nodes' terminal flags
        this.initializeGame();
        this.attachCanvasHandlers();
    }

    initializeGame() {
        this.createDefaultGraph();
        this.renderGame();
        this.updateUI();
    }

    // ---------- GRAPH CREATION ----------
    createDefaultGraph() {
        // 6-node starter graph (same geometry as your original)
        this.nodes = [
            {x:100, y:220, terminal:true},
            {x:230, y:110, terminal:false},
            {x:230, y:330, terminal:false},
            {x:440, y:110, terminal:false},
            {x:440, y:330, terminal:false},
            {x:580, y:220, terminal:true}
        ];
        this.edges = [
            {from:0, to:1, state:'neutral'},
            {from:0, to:2, state:'neutral'},
            {from:1, to:3, state:'neutral'},
            {from:1, to:4, state:'neutral'},
            {from:2, to:3, state:'neutral'},
            {from:2, to:4, state:'neutral'},
            {from:3, to:5, state:'neutral'},
            {from:4, to:5, state:'neutral'},
            {from:1, to:2, state:'neutral'},
            {from:3, to:4, state:'neutral'}
        ];
        this.currentPlayer = 'short';
        this.gameOver = false;
        this.winner = null;
    }

    clearGraphOnly() {
        this.nodes = [];
        this.edges = [];
        this.currentPlayer = 'short';
        this.gameOver = false;
        this.winner = null;
        this.pendingEdgeFrom = null;
        this.draggingNode = null;
    }

    getTerminals() {
        const t = [];
        this.nodes.forEach((n, i) => { if (n.terminal) t.push(i); });
        return t;
    }

    // ---------- RENDER ----------
    renderGame() {
        const svg = document.getElementById('gameBoard');
        svg.innerHTML = '';

        // Edges first
        this.edges.forEach((edge, index) => {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            const fromNode = this.nodes[edge.from];
            const toNode = this.nodes[edge.to];

            line.setAttribute('x1', fromNode.x);
            line.setAttribute('y1', fromNode.y);
            line.setAttribute('x2', toNode.x);
            line.setAttribute('y2', toNode.y);

            let cls = `edge ${edge.state}`;
            // Show a subtle edit style in addEdge mode after first click
            if (this.mode === 'addEdge' && (this.pendingEdgeFrom === edge.from || this.pendingEdgeFrom === edge.to)) {
                cls += ' editing';
            }
            line.setAttribute('class', cls);

            // Click behavior depends on mode
            line.addEventListener('click', (e) => {
                e.stopPropagation();
                if (this.mode === 'play') {
                    this.handleEdgeClick(index);
                } else if (this.mode === 'delete') {
                    this.deleteEdge(index);
                }
            });

            svg.appendChild(line);
        });

        // Nodes
        this.nodes.forEach((node, index) => {
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', node.x);
            circle.setAttribute('cy', node.y);
            circle.setAttribute('r', 15);
            circle.setAttribute('class', node.terminal ? 'node terminal' : 'node regular-node');
            
            // Make sure the entire circle (including transparent area) is clickable
            circle.setAttribute('pointer-events', 'all');
            
            // Node interactions by mode
            circle.addEventListener('click', (e) => {
                e.stopPropagation();
                if (this.mode === 'addEdge') {
                    this.addEdgeStep(index);  // always trigger edge creation
                } else if (this.mode === 'toggleTerminal') {
                    this.toggleTerminal(index);
                } else if (this.mode === 'delete') {
                    this.deleteNode(index);
                }
            });
            
            // Move (drag) support
            if (this.mode === 'move') {
                circle.style.cursor = 'grab';
                circle.addEventListener('mousedown', (e) => this.startDrag(e, index));
            }
            
            svg.appendChild(circle);
            
            // Labels
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', node.x);
            text.setAttribute('y', node.y + 5);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-family', 'Arial');
            text.setAttribute('font-size', '12');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('fill', 'white');
            text.textContent = node.terminal ? 'T' : index;
            svg.appendChild(text);
        });
    }

    // ---------- PLAY LOGIC ----------
    handleEdgeClick(edgeIndex) {
        if (this.gameOver || this.edges[edgeIndex].state !== 'neutral') return;

        const terminals = this.getTerminals();
        if (terminals.length !== 2) {
            this.flashBuilderStatus('Set exactly two terminals to play (Mode → Toggle Terminal).');
            return;
        }

        this.edges[edgeIndex].state = (this.currentPlayer === 'short') ? 'connected' : 'cut';
        this.checkGameEnd();
        if (!this.gameOver) {
            this.currentPlayer = (this.currentPlayer === 'short') ? 'cut' : 'short';
        }
        this.renderGame();
        this.updateUI();
    }

    checkGameEnd() {
        const terminals = this.getTerminals();
        if (terminals.length !== 2) return; // cannot determine yet

        if (this.hasPathBetween(terminals[0], terminals[1])) {
            this.gameOver = true;
            this.winner = 'Short (Connector)';
            return;
        }
        if (this.isConnectionImpossible(terminals[0], terminals[1])) {
            this.gameOver = true;
            this.winner = 'Cut (Blocker)';
            return;
        }
    }

    hasPathBetween(s, t) {
        // DFS over edges with state 'connected'
        const visited = new Set();
        const stack = [s];
        while (stack.length) {
            const cur = stack.pop();
            if (cur === t) return true;
            if (visited.has(cur)) continue;
            visited.add(cur);
            this.edges.forEach(e => {
                if (e.state === 'connected') {
                    if (e.from === cur && !visited.has(e.to)) stack.push(e.to);
                    else if (e.to === cur && !visited.has(e.from)) stack.push(e.from);
                }
            });
        }
        return false;
    }

    isConnectionImpossible(s, t) {
        // DFS over edges that are NOT cut (neutral or connected).
        const visited = new Set();
        const stack = [s];
        while (stack.length) {
            const cur = stack.pop();
            if (cur === t) return false; // still possible
            if (visited.has(cur)) continue;
            visited.add(cur);
            this.edges.forEach(e => {
                if (e.state !== 'cut') {
                    if (e.from === cur && !visited.has(e.to)) stack.push(e.to);
                    else if (e.to === cur && !visited.has(e.from)) stack.push(e.from);
                }
            });
        }
        return true;
    }

    updateUI() {
        const currentPlayerElement = document.getElementById('currentPlayer');
        const gameStatusElement = document.getElementById('gameStatus');
        const winnerElement = document.getElementById('winner');

        if (this.gameOver) {
            currentPlayerElement.textContent = 'Game Over';
            gameStatusElement.textContent = `${this.winner} wins!`;
            winnerElement.textContent = `🎉 ${this.winner} Wins! 🎉`;
            winnerElement.style.display = 'block';
        } else {
            const playerName = this.currentPlayer === 'short' ? 'Short (Connector)' : 'Cut (Blocker)';
            currentPlayerElement.textContent = `Current Player: ${playerName}`;
            gameStatusElement.textContent = (this.mode === 'play') ? 'Game in progress' : `Editing: ${this.mode}`;
            winnerElement.style.display = 'none';
        }

        // Builder hint
        const hint = document.getElementById('editHint');
        const builderStatus = document.getElementById('builderStatus');
        const t = this.getTerminals().length;
        builderStatus.textContent = (this.mode === 'play')
            ? (t === 2 ? '' : 'Tip: Choose exactly two terminals (Mode → Toggle Terminal) to play.')
            : '';
        if (this.mode === 'addEdge') {
            hint.textContent = 'Tip: In Add Edge mode, click two nodes to connect them.';
        } else if (this.mode === 'addNode') {
            hint.textContent = 'Tip: In Add Node mode, click empty space on the canvas to place a node.';
        } else if (this.mode === 'toggleTerminal') {
            hint.textContent = 'Tip: Click a node to toggle terminal. Exactly two should be red (T).';
        } else if (this.mode === 'delete') {
            hint.textContent = 'Tip: Click a node or an edge to delete it.';
        } else if (this.mode === 'move') {
            hint.textContent = 'Tip: Drag a node to reposition it.';
        } else {
            hint.textContent = 'Tip: Switch to Edit modes to build a custom graph.';
        }
    }

    // ---------- EDIT MODES ----------
    setMode(m) {
        this.mode = m;
        this.pendingEdgeFrom = null;
        this.draggingNode = null;
        this.renderGame();
        this.updateUI();
    }

    attachCanvasHandlers() {
        const svg = document.getElementById('gameBoard');
        // Add node on empty canvas click
        svg.addEventListener('click', (e) => {
            if (this.mode !== 'addNode') return;
            const pt = this.getSVGPoint(e);
            // Prevent placing too close to existing nodes (radius 24)
            if (!this.isFarFromNodes(pt.x, pt.y, 24)) {
                this.flashBuilderStatus('Too close to another node.');
                return;
            }
            this.nodes.push({x: pt.x, y: pt.y, terminal: false});
            this.renderGame();
            this.updateUI();
        });

        // End dragging if any
        window.addEventListener('mouseup', () => {
            this.draggingNode = null;
        });
        window.addEventListener('mousemove', (e) => {
            if (this.draggingNode === null) return;
            const pt = this.getSVGPoint(e);
            const n = this.nodes[this.draggingNode];
            n.x = Math.max(20, Math.min(pt.x, svg.clientWidth - 20));
            n.y = Math.max(20, Math.min(pt.y, svg.clientHeight - 20));
            this.renderGame();
        });
    }

    getSVGPoint(e) {
        const svg = document.getElementById('gameBoard');
        const rect = svg.getBoundingClientRect();
        return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    }

    isFarFromNodes(x, y, minDist=24) {
        return this.nodes.every(n => {
            const dx = n.x - x, dy = n.y - y;
            return Math.hypot(dx, dy) >= minDist;
        });
    }

    addEdgeStep(nodeIndex) {
        if (this.pendingEdgeFrom === null) {
            this.pendingEdgeFrom = nodeIndex;
            this.updateUI();
        } else if (this.pendingEdgeFrom === nodeIndex) {
            // same node clicked; cancel
            this.pendingEdgeFrom = null;
            this.updateUI();
        } else {
            const a = this.pendingEdgeFrom, b = nodeIndex;
            this.pendingEdgeFrom = null;
            if (this.edgeExists(a, b)) {
                this.flashBuilderStatus('Edge already exists.');
                return;
            }
            this.edges.push({from: Math.min(a,b), to: Math.max(a,b), state:'neutral'});
            this.renderGame();
            this.updateUI();
        }
    }

    edgeExists(a, b) {
        const x = Math.min(a,b), y = Math.max(a,b);
        return this.edges.some(e => e.from === x && e.to === y);
    }

    toggleTerminal(index) {
        const terminals = this.getTerminals();
        const isTerm = this.nodes[index].terminal;
        if (isTerm) {
            // turning off is always ok
            this.nodes[index].terminal = false;
        } else {
            // turning on: allow up to 2, else replace the "older" one
            if (terminals.length < 2) {
                this.nodes[index].terminal = true;
            } else {
                // Replace the first terminal to keep exactly two
                const oldIdx = terminals[0];
                this.nodes[oldIdx].terminal = false;
                this.nodes[index].terminal = true;
            }
        }
        // Reset game states when topology/terminals change
        this.resetEdgeStates();
        this.currentPlayer = 'short';
        this.gameOver = false;
        this.winner = null;
        this.renderGame();
        this.updateUI();
    }

    deleteNode(index) {
        // Remove incident edges
        this.edges = this.edges.filter(e => e.from !== index && e.to !== index)
            .map(e => ({
                from: e.from > index ? e.from - 1 : e.from,
                to: e.to > index ? e.to - 1 : e.to,
                state: e.state
            }));
        this.nodes.splice(index, 1);
        this.resetEdgeStates();
        this.currentPlayer = 'short';
        this.gameOver = false;
        this.winner = null;
        this.renderGame();
        this.updateUI();
    }

    deleteEdge(edgeIndex) {
        this.edges.splice(edgeIndex, 1);
        this.resetEdgeStates();
        this.currentPlayer = 'short';
        this.gameOver = false;
        this.winner = null;
        this.renderGame();
        this.updateUI();
    }

    resetEdgeStates() {
        this.edges.forEach(e => e.state = 'neutral');
    }

    startDrag(e, nodeIndex) {
        this.draggingNode = nodeIndex;
        const svg = document.getElementById('gameBoard');
        svg.style.cursor = 'grabbing';
        // Return mouse cursor when done
        const release = () => { svg.style.cursor = 'default'; window.removeEventListener('mouseup', release); };
        window.addEventListener('mouseup', release);
    }

    // ---------- SAVE / LOAD ----------
    toJSON() {
        return JSON.stringify({nodes: this.nodes, edges: this.edges});
    }

    fromJSON(json) {
        try {
            const obj = JSON.parse(json);
            if (!Array.isArray(obj.nodes) || !Array.isArray(obj.edges)) throw new Error();
            // Sanitize nodes
            this.nodes = obj.nodes.map(n => ({
                x: +n.x, y: +n.y, terminal: !!n.terminal
            }));
            // Sanitize edges
            this.edges = obj.edges.map(e => {
                const from = Math.min(+e.from, +e.to);
                const to = Math.max(+e.from, +e.to);
                return {from, to, state: 'neutral'};
            }).filter(e => e.from >= 0 && e.to < this.nodes.length && e.from !== e.to);
            // reset game state
            this.currentPlayer = 'short';
            this.gameOver = false;
            this.winner = null;
            this.renderGame();
            this.updateUI();
            this.flashBuilderStatus('Graph loaded.');
        } catch {
            this.flashBuilderStatus('Invalid graph data.');
        }
    }

    // ---------- UTILS ----------
    flashBuilderStatus(msg) {
        const el = document.getElementById('builderStatus');
        el.textContent = msg;
        el.style.transition = 'none';
        el.style.opacity = '1';
        setTimeout(() => {
            el.style.transition = 'opacity .6s ease';
            el.style.opacity = '0';
            setTimeout(() => { el.textContent = ''; el.style.opacity = '1'; }, 700);
        }, 1400);
    }

    reset() {
        this.createDefaultGraph();
        this.renderGame();
        this.updateUI();
    }
}

// Global game instance
let game = new ShannonSwitchingGame();

// Existing controls
function resetGame(){ game.reset(); }
function toggleRules(){
    const rules = document.getElementById('rules');
    rules.classList.toggle('show');
}

// New: mode switching
function setMode(v){
    game.setMode(v);
    const sel = document.getElementById('modeSelect');
    if (sel.value !== v) sel.value = v;
}

// New: clear, save, load
function clearGraph(){
    game.clearGraphOnly();
    game.renderGame();
    game.updateUI();
}
function saveGraph(){
    const data = game.toJSON();
    localStorage.setItem('shannon_custom_graph', data);
    game.flashBuilderStatus('Graph saved to your browser.');
}
function loadGraph(){
    const data = localStorage.getItem('shannon_custom_graph');
    if (!data) { game.flashBuilderStatus('No saved graph found.'); return; }
    game.fromJSON(data);
}

// Keyboard shortcuts (optional niceties)
window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        setMode('play');
    } else if (e.key.toLowerCase() === 'a') {
        setMode('addNode');
    } else if (e.key.toLowerCase() === 'e') {
        setMode('addEdge');
    } else if (e.key.toLowerCase() === 't') {
        setMode('toggleTerminal');
    } else if (e.key.toLowerCase() === 'd') {
        setMode('delete');
    } else if (e.key.toLowerCase() === 'm') {
        setMode('move');
    }
});
</script>
</body>
</html>
